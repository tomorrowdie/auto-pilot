"""
Snapshot-to-Markdown converters — The "USB Protocol".

Each data source has its own converter function that transforms
its native output dict into a standardized Markdown string.
The KnowledgeManager Hub then saves that string as-is.

Usage:
    from V2_Engine.knowledge_base.converters import snapshot_to_markdown
    md = snapshot_to_markdown("Garlic Press Q1", snapshot)
    kb.save_insight("0_catalog_insight", filename, md)
"""

from __future__ import annotations

from datetime import datetime


def _fmt(value, prefix: str = "", suffix: str = "", decimals: int = 2) -> str:
    """Format a numeric value for Markdown, returning a dash if None."""
    if value is None:
        return "\u2014"
    if isinstance(value, float):
        return f"{prefix}{value:,.{decimals}f}{suffix}"
    return f"{prefix}{value:,}{suffix}"


# ==================================================================
# Source 0 — Market Data (H10 Xray / Cerebro) converter
# ==================================================================

def snapshot_to_markdown(
    title: str,
    snap: dict,
    source_type: str = "market_data",
) -> str:
    """
    Convert a MarketAnalyzer snapshot dict into AI-optimized Markdown.

    This is the standard "USB Protocol" for Source 0 data flowing
    into the Knowledge Base Hub.
    """
    lines: list[str] = []
    now = datetime.now().strftime("%Y-%m-%d %H:%M")

    lines.append(f"# {title}")
    lines.append("")
    lines.append(f"- **Source type:** {source_type}")
    lines.append(f"- **Generated:** {now}")

    meta = snap.get("meta", {})
    total_rows = meta.get("total_rows", "\u2014")
    lines.append(f"- **Total rows:** {total_rows:,}")
    lines.append("")

    _section_brands(lines, snap.get("brands", {}))
    _section_sellers(lines, snap.get("sellers", {}))
    _section_pricing(lines, snap.get("pricing", {}))
    _section_sales(lines, snap.get("sales", {}))
    _section_performance(lines, snap.get("performance", {}))
    _section_characteristics(lines, snap.get("characteristics", {}))

    lines.append("")
    lines.append("---")
    lines.append("*Auto-generated by Catalog Insight V2 Engine.*")
    lines.append("")

    return "\n".join(lines)


# ------------------------------------------------------------------
# Section renderers
# ------------------------------------------------------------------

def _section_brands(lines: list[str], data: dict) -> None:
    lines.append("## Market Health \u2014 Brand Landscape")
    lines.append("")

    if "error" in data:
        lines.append(f"- *No brand data available:* {data['error']}")
        lines.append("")
        return

    lines.append(f"- **Total brands:** {_fmt(data.get('total_brands'))}")
    lines.append(f"- **Total products:** {_fmt(data.get('total_products'))}")

    hhi = data.get("hhi", {})
    score = hhi.get("score")
    if score is not None:
        lines.append(f"- **HHI Score:** {_fmt(score, decimals=0)}")
        classification = hhi.get("classification", "\u2014")
        interpretation = hhi.get("interpretation", "\u2014")
        lines.append(f"- **Classification:** {classification}")
        lines.append(f"- **Interpretation:** {interpretation}")
    lines.append("")

    top_brands = data.get("top_brands", [])
    if top_brands:
        lines.append("### Top Brands")
        lines.append("")
        for i, b in enumerate(top_brands, 1):
            name = b.get("brand", "Unknown")
            share = b.get("market_share_pct", 0)
            count = b.get("product_count", 0)
            parts = [f"{share}% share", f"{count} products"]
            if b.get("avg_price") is not None:
                parts.append(f"avg ${b['avg_price']:,.2f}")
            if b.get("avg_rating") is not None:
                parts.append(f"rating {b['avg_rating']}")
            if b.get("avg_sales") is not None:
                parts.append(f"avg sales {b['avg_sales']:,.0f}")
            lines.append(f"{i}. **{name}** \u2014 {', '.join(parts)}")
        lines.append("")


def _section_sellers(lines: list[str], data: dict) -> None:
    lines.append("## Seller Analytics")
    lines.append("")

    lines.append(f"- **Total sellers:** {_fmt(data.get('total_sellers'))}")

    amz_dom = data.get("amazon_dominance_pct")
    if amz_dom is not None:
        lines.append(f"- **Amazon dominance:** {_fmt(amz_dom, suffix='%')}")

    age = data.get("avg_seller_age_months")
    if age is not None:
        lines.append(f"- **Avg seller age:** {_fmt(age, decimals=0)} months")

    dist = data.get("country_distribution", {})
    if dist:
        lines.append("")
        lines.append("### Country Distribution")
        lines.append("")
        for code, info in dist.items():
            pct = info.get("pct", 0)
            rev = info.get("revenue_share", 0)
            lines.append(
                f"- **{code}:** {info.get('count', 0)} sellers "
                f"({pct}% of total, {rev}% revenue share)"
            )
    lines.append("")


def _section_pricing(lines: list[str], data: dict) -> None:
    lines.append("## Pricing & Profitability")
    lines.append("")

    if "error" in data:
        lines.append(f"- *No pricing data available:* {data['error']}")
        lines.append("")
        return

    totals = data.get("totals", {})
    lines.append(f"- **Avg price:** {_fmt(totals.get('avg_price'), prefix='$')}")
    lines.append(f"- **Avg fees:** {_fmt(totals.get('avg_fee'), prefix='$')}")
    lines.append(f"- **Avg profit:** {_fmt(totals.get('avg_profit'), prefix='$')}")
    lines.append(f"- **Median price:** {_fmt(totals.get('median_price'), prefix='$')}")
    lines.append(
        f"- **Price range:** "
        f"{_fmt(totals.get('min_price'), prefix='$')} \u2014 "
        f"{_fmt(totals.get('max_price'), prefix='$')}"
    )
    lines.append("")

    by_rank = data.get("by_rank", {})
    if by_rank:
        lines.append("### Pricing by Rank Tier")
        lines.append("")
        lines.append("| Tier | Count | Avg Price | Avg Fee | Avg Profit | Median |")
        lines.append("|------|------:|----------:|--------:|-----------:|-------:|")
        for tier, v in by_rank.items():
            cnt = v.get("count", 0)
            if cnt == 0:
                continue
            lines.append(
                f"| {tier} | {cnt} "
                f"| {_fmt(v.get('avg_price'), prefix='$')} "
                f"| {_fmt(v.get('avg_fee'), prefix='$')} "
                f"| {_fmt(v.get('avg_profit'), prefix='$')} "
                f"| {_fmt(v.get('p50'), prefix='$')} |"
            )
        lines.append("")


def _section_sales(lines: list[str], data: dict) -> None:
    lines.append("## Sales & Revenue")
    lines.append("")

    if "error" in data:
        lines.append(f"- *No sales data available:* {data['error']}")
        lines.append("")
        return

    metric_cols = data.get("metrics_columns", [])
    totals = data.get("totals", {})
    lines.append(f"- **Total products:** {_fmt(totals.get('total_products'))}")
    for col in metric_cols:
        val = totals.get(col)
        lines.append(f"- **Avg {col}:** {_fmt(val)}")
    lines.append("")

    by_rank = data.get("by_rank", {})
    if by_rank and metric_cols:
        lines.append("### Sales by Rank Tier")
        lines.append("")
        header_cols = " | ".join(metric_cols)
        lines.append(f"| Tier | Count | {header_cols} |")
        sep = " | ".join(["------:"] * len(metric_cols))
        lines.append(f"|------|------:| {sep} |")
        for tier, v in by_rank.items():
            vals = " | ".join(_fmt(v.get(c)) for c in metric_cols)
            lines.append(f"| {tier} | {v.get('count', 0)} | {vals} |")
        lines.append("")


def _section_performance(lines: list[str], data: dict) -> None:
    lines.append("## Product Performance")
    lines.append("")

    if "error" in data:
        lines.append(f"- *No performance data available:* {data['error']}")
        lines.append("")
        return

    totals = data.get("totals", {})
    resolved = data.get("resolved_columns", {})

    for key, col_name in resolved.items():
        if col_name is None:
            continue
        val = totals.get(key)
        lines.append(f"- **{key}** ({col_name}): {_fmt(val)}")
    lines.append("")


def _section_characteristics(lines: list[str], data: dict) -> None:
    lines.append("## Product Characteristics")
    lines.append("")

    if "error" in data:
        lines.append(f"- *No characteristics data available:* {data['error']}")
        lines.append("")
        return

    totals = data.get("totals", {})
    lines.append(f"- **Avg weight:** {_fmt(totals.get('avg_weight_lbs'), suffix=' lbs')}")
    vol_suffix = " in\u00b3"
    lines.append(f"- **Avg volume:** {_fmt(totals.get('avg_volume_in3'), suffix=vol_suffix)}")

    top_cat = totals.get("top_category")
    if top_cat and isinstance(top_cat, dict):
        cat_value = top_cat.get("value", "\u2014")
        cat_pct = top_cat.get("pct", 0)
        lines.append(f"- **Top category:** {cat_value} ({cat_pct}%)")

    size_dist = totals.get("size_distribution", [])
    if size_dist:
        lines.append("- **Size distribution:**")
        for s in size_dist:
            s_val = s.get("value", "\u2014")
            s_pct = s.get("pct", 0)
            lines.append(f"  - {s_val}: {s_pct}%")
    lines.append("")
